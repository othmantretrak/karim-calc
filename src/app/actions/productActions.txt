// app/actions/productActions.ts
'use server'

import prisma from '@/app/lib/prisma'
import { revalidatePath } from 'next/cache'

// Helper interface for conditional logic structure used in transit
interface ConditionalData {
    stepId: string; // tempId or real ID from the client
    value: string;
    questionNum: 1 | 2; // Which question (1 or 2) in the parent step sets the condition
}

interface StepOptionData {
    questionNum: number
    label: string
    value: string
    price: number | null
    order: number
}

interface StepData {
    tempId?: string
    id?: string
    order: number

    // Question 1 (required)
    type1: 'SELECT' | 'NUMBER'
    question1: string
    required1: boolean
    pricingImpact1: 'BASE' | 'MULTIPLIER' | 'ADDITIVE' | 'NONE'
    pricePerUnit1?: number | null
    unit1?: string | null
    minValue1?: number | null
    maxValue1?: number | null
    defaultValue1?: number | null

    // Question 2 (optional)
    type2?: 'SELECT' | 'NUMBER' | null
    question2?: string | null
    required2?: boolean
    pricingImpact2?: 'BASE' | 'MULTIPLIER' | 'ADDITIVE' | 'NONE'
    pricePerUnit2?: number | null
    unit2?: string | null
    minValue2?: number | null
    maxValue2?: number | null
    defaultValue2?: number | null

    conditionalOn?: ConditionalData | null
    options?: StepOptionData[]
}

interface ProductFormData {
    name: string
    slug: string
    description?: string
    steps: StepData[]
}

export async function createProduct(formData: ProductFormData) {
    try {
        if (!formData.name || !formData.slug) {
            return { success: false, error: 'Product name and slug are required' }
        }

        const existingProduct = await prisma.product.findUnique({
            where: { slug: formData.slug }
        })

        if (existingProduct) {
            return { success: false, error: 'A product with this slug already exists' }
        }

        const result = await prisma.$transaction(async (tx) => {
            const product = await tx.product.create({
                data: {
                    name: formData.name,
                    slug: formData.slug,
                    description: formData.description || null,
                },
            })

            // Map used to resolve temporary IDs of steps to their new database IDs
            const stepIdMap = new Map<string, string>()

            // First pass: Create all steps (excluding conditionalOn initially)
            const createdSteps = await Promise.all(
                formData.steps.map(async (stepData) => {
                    const step = await tx.formStep.create({
                        data: {
                            productId: product.id,
                            order: stepData.order,

                            // Question 1
                            type1: stepData.type1,
                            question1: stepData.question1,
                            required1: stepData.required1,
                            pricingImpact1: stepData.pricingImpact1,
                            pricePerUnit1: stepData.pricePerUnit1 ?? null,
                            unit1: stepData.unit1 ?? null,
                            minValue1: stepData.minValue1 ?? null,
                            maxValue1: stepData.maxValue1 ?? null,
                            defaultValue1: stepData.defaultValue1 ?? null,

                            // Question 2
                            type2: stepData.type2 ?? null,
                            question2: stepData.question2 ?? null,
                            required2: stepData.required2 ?? false,
                            pricingImpact2: stepData.pricingImpact2 ?? 'NONE',
                            pricePerUnit2: stepData.pricePerUnit2 ?? null,
                            unit2: stepData.unit2 ?? null,
                            minValue2: stepData.minValue2 ?? null,
                            maxValue2: stepData.maxValue2 ?? null,
                            defaultValue2: stepData.defaultValue2 ?? null,

                            conditionalOn: undefined,
                        },
                    })

                    if (stepData.tempId) {
                        stepIdMap.set(stepData.tempId, step.id)
                    }

                    return { step, stepData }
                })
            )

            // Second pass: Update conditional logic and create options
            for (const { step, stepData } of createdSteps) {
                if (stepData.conditionalOn) {
                    const conditional = stepData.conditionalOn;

                    // Look up the actual new ID if the referenced step was new (used tempId)
                    const referencedStepId = stepIdMap.get(conditional.stepId) || conditional.stepId

                    await tx.formStep.update({
                        where: { id: step.id },
                        data: {
                            conditionalOn: {
                                stepId: referencedStepId,
                                value: conditional.value,
                                questionNum: conditional.questionNum, // Store questionNum
                            },
                        },
                    })
                }

                // Create options
                if (stepData.options && stepData.options.length > 0) {
                    await tx.stepOption.createMany({
                        data: stepData.options.map((option) => ({
                            stepId: step.id,
                            questionNum: option.questionNum,
                            label: option.label,
                            value: option.value,
                            price: option.price,
                            order: option.order,
                        })),
                    })
                }
            }

            return product
        })

        revalidatePath('/products')
        revalidatePath('/')

        return { success: true, productId: result.id, slug: result.slug }
    } catch (error) {
        console.error('Error creating product:', error)
        return { success: false, error: 'Failed to create product' }
    }
}

export async function updateProduct(productId: string, formData: ProductFormData) {
    try {
        if (!formData.name || !formData.slug) {
            return { success: false, error: 'Product name and slug are required' }
        }

        const existingProduct = await prisma.product.findUnique({
            where: { id: productId }
        })

        if (!existingProduct) {
            return { success: false, error: 'Product not found' }
        }

        const slugConflict = await prisma.product.findFirst({
            where: {
                slug: formData.slug,
                id: { not: productId }
            }
        })

        if (slugConflict) {
            return { success: false, error: 'This slug is already used by another product' }
        }

        await prisma.$transaction(async (tx) => {
            // Delete existing steps (cascade will delete options)
            await tx.formStep.deleteMany({
                where: { productId },
            })

            // Update product
            await tx.product.update({
                where: { id: productId },
                data: {
                    name: formData.name,
                    slug: formData.slug,
                    description: formData.description || null,
                },
            })

            const stepIdMap = new Map<string, string>()

            // Create new steps
            const createdSteps = await Promise.all(
                formData.steps.map(async (stepData) => {
                    const step = await tx.formStep.create({
                        data: {
                            productId,
                            order: stepData.order,

                            // Question 1
                            type1: stepData.type1,
                            question1: stepData.question1,
                            required1: stepData.required1,
                            pricingImpact1: stepData.pricingImpact1,
                            pricePerUnit1: stepData.pricePerUnit1 ?? null,
                            unit1: stepData.unit1 ?? null,
                            minValue1: stepData.minValue1 ?? null,
                            maxValue1: stepData.maxValue1 ?? null,
                            defaultValue1: stepData.defaultValue1 ?? null,

                            // Question 2
                            type2: stepData.type2 ?? null,
                            question2: stepData.question2 ?? null,
                            required2: stepData.required2 ?? false,
                            pricingImpact2: stepData.pricingImpact2 ?? 'NONE',
                            pricePerUnit2: stepData.pricePerUnit2 ?? null,
                            unit2: stepData.unit2 ?? null,
                            minValue2: stepData.minValue2 ?? null,
                            maxValue2: stepData.maxValue2 ?? null,
                            defaultValue2: stepData.defaultValue2 ?? null,

                            conditionalOn: undefined,
                        },
                    })

                    // Map the tempId (or old ID if editing) to the new ID
                    const key = stepData.tempId || stepData.id
                    if (key) {
                        stepIdMap.set(key, step.id)
                    }

                    return { step, stepData }
                })
            )

            // Update conditional logic and create options
            for (const { step, stepData } of createdSteps) {
                if (stepData.conditionalOn) {
                    const conditional = stepData.conditionalOn;

                    // Look up the actual new ID using the map. This works whether the referenced step
                    // was new (tempId mapped) or existing (old ID mapped to new ID).
                    const referencedStepId = stepIdMap.get(conditional.stepId) || conditional.stepId

                    await tx.formStep.update({
                        where: { id: step.id },
                        data: {
                            conditionalOn: {
                                stepId: referencedStepId,
                                value: conditional.value,
                                questionNum: conditional.questionNum, // Store questionNum
                            },
                        },
                    })
                }

                if (stepData.options && stepData.options.length > 0) {
                    await tx.stepOption.createMany({
                        data: stepData.options.map((option) => ({
                            stepId: step.id,
                            questionNum: option.questionNum,
                            label: option.label,
                            value: option.value,
                            price: option.price,
                            order: option.order,
                        })),
                    })
                }
            }
        })

        revalidatePath('/products')
        revalidatePath(`/products/${formData.slug}`)
        revalidatePath('/')

        return { success: true, productId, slug: formData.slug }
    } catch (error) {
        console.error('Error updating product:', error)
        return { success: false, error: 'Failed to update product' }
    }
}

export async function deleteProduct(productId: string) {
    try {
        const product = await prisma.product.findUnique({
            where: { id: productId }
        })

        if (!product) {
            return { success: false, error: 'Product not found' }
        }

        await prisma.product.delete({
            where: { id: productId },
        })

        revalidatePath('/products')
        revalidatePath('/')

        return { success: true }
    } catch (error) {
        console.error('Error deleting product:', error)
        return { success: false, error: 'Failed to delete product' }
    }
}

// Type definition for the conditional logic stored in JSON
type ConditionalLogic = { stepId: string; value: string; questionNum: 1 | 2 } | null

export async function getAllProducts() {
    try {
        const products = await prisma.product.findMany({
            include: {
                steps: {
                    orderBy: { order: 'asc' },
                    include: {
                        options: {
                            orderBy: { order: 'asc' }
                        }
                    }
                }
            },
            orderBy: { createdAt: 'desc' }
        })

        // Transform conditionalOn from Json to proper type
        const transformedProducts = products.map(product => ({
            ...product,
            steps: product.steps.map(step => ({
                ...step,
                conditionalOn: step.conditionalOn as ConditionalLogic
            }))
        }))

        return transformedProducts
    } catch (error) {
        console.error('Error fetching products:', error)
        return []
    }
}

export async function getProductBySlug(slug: string) {
    try {
        const product = await prisma.product.findUnique({
            where: { slug },
            include: {
                steps: {
                    orderBy: { order: 'asc' },
                    include: {
                        options: {
                            orderBy: { order: 'asc' }
                        }
                    }
                }
            }
        })

        if (!product) {
            return null
        }

        // Transform conditionalOn from Json to proper type
        return {
            ...product,
            steps: product.steps.map(step => ({
                ...step,
                conditionalOn: step.conditionalOn as ConditionalLogic
            }))
        }
    } catch (error) {
        console.error('Error fetching product:', error)
        return null
    }
}

export async function getProductById(id: string) {
    try {
        const product = await prisma.product.findUnique({
            where: { id },
            include: {
                steps: {
                    orderBy: { order: 'asc' },
                    include: {
                        options: {
                            orderBy: { order: 'asc' }
                        }
                    }
                }
            }
        })

        if (!product) {
            return null
        }

        // Transform conditionalOn from Json to proper type
        return {
            ...product,
            steps: product.steps.map(step => ({
                ...step,
                conditionalOn: step.conditionalOn as ConditionalLogic
            }))
        }
    } catch (error) {
        console.error('Error fetching product:', error)
        return null
    }
}